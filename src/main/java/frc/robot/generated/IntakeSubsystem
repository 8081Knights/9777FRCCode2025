package frc.robot;

import com.revrobotics.CANSparkF;
import com.revrobotics.CANSparkMax.ControlType;
import com.revrobotics.RelativeEncoder;

import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

public class IntakeSubstystem {
    //right intake motor
    CANSparkMax mIntakeRight;
    //left intake motor
    CANSparkMax mIntakeLeft;

    //right intake encoder
    RelativeEncoder encoderRight;
    //left intake encoder
    RelativeEncoder encoderLeft;


    SPARKPIDController intakeLeftPID;
    SPARKPIDController intakeRightPID;

    //PID Gains
    public double kP, kI, kD, kIZone, kFF, maxOutput, minOutput;

    /**
     * @param intakeCANIDLeft The CAN ID of the left intake motor
     * @param intakeCANIDRight The CAN ID of the right intake motor
     */
    IntakeSubsystem(int intakeCANLeft, int intakeCANRight){

        //add the intake motors
        mIntakeRight = new CANSparkMax(intakeCANRight, CANSparkLowLevel.MotorType.kBrushless);
        mIntakeLeft = new CANSparkMax(intakeCANLeft, CANSparkLowLevel.MotorType.kBrushless);

        //get encoders from intake motors
        encoderRight = mIntakeRight.getEncoder();
        encoderLeft = mIntakeLeft.getEncoder();

        intakeLeftPID = mIntakeLeft.getPIDController();
        intakeRightPID = mIntakeRight.getPIDController();

        intakeLeftPID.setP(kP);
        intakeLeftPID.setI(kI);
        intakeLeftPID.setD(kD);
        intakeLeftPID.setIZone(kIZone);
        intakeLeftPID.setFF(kFF);
        intakeLeftPID.setOutputRange(minOutput, maxOutput);
        
        // now set the PID values for the right motor
        intakeRightPID.setP(kP);
        intakeRightPID.setI(kI);
        intakeRightPID.setD(kD);
        intakeRightPID.setIZone(kIZone);
        intakeRightPID.setFF(kFF);
        intakeRightPID.setOutputRange(minOutput, maxOutput);


        //set the motor gear rations for calculations
        encoderLeft.setVelocityConversionFactor(1/5);
        encoderRight.setVelocityConversionFactor(1/5);
    }

    public void constantChange(double p, double i, double d, double iZone, double f, double max, double min) {
        deliveryLeftPID.setP(p);
        deliveryLeftPID.setI(i);
        deliveryLeftPID.setD(d);
        deliveryLeftPID.setIZone(iZone);
        deliveryLeftPID.setFF(f);
        deliveryLeftPID.setOutputRange(min, max);
        
        // now set the PID values for the right motor
        deliveryRightPID.setP(p);
        deliveryRightPID.setI(i);
        deliveryRightPID.setD(d);
        deliveryRightPID.setIZone(iZone);
        deliveryRightPID.setFF(f);
        deliveryRightPID.setOutputRange(min, max);

    }

    /**
    * @param velocity The target velocity for the delivery motor, unit is RPM at the flywheel OLD MESSAGE
    */
    public void deliver(double velocity){

        //current velocity of the motors
        double currentVRight = encoderRight.getVelocity();
        double currentVLeft = encoderLeft.getVelocity();

        //get the PID outputs based on current and target velocity
        deliveryLeftPID.setReference(velocity, CANSparkMax.ControlType.kVelocity);
        deliveryRightPID.setReference(velocity, CANSparkMax.ControlType.kVelocity);

        SmartDashboard.putNumber("Left Intake Motor Speed", currentVLeft);
        SmartDashboard.putNumber("Right Intake Motor Speed", currentVRight);

        // Ensure the outputs are within the valid range of -1 to 1
        // outputRight = Math.max(-1.0, Math.min(1.0, outputRight));
        // outputLeft = Math.max(-1.0, Math.min(1.0, outputLeft));
    }

    public void stop(){
        mDeliveryRight.set(0);
        mDeliveryLeft.set(0);
    }

    public void setSpeed(double speed) {
        mDeliveryRight.set(speed);
        mDeliveryLeft.set(speed);
    }

}